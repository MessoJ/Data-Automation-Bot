"""
Flask application factory and configuration.

This module creates and configures the Flask application for the 
Data Automation Bot web interface.
"""

import os
import logging
from flask import Flask, render_template, jsonify, request, send_file, send_from_directory
from flask_cors import CORS
from datetime import datetime, timedelta
import json

# Import bot components
from database.db_manager import DatabaseManager
from reporting.report_generator import ReportGenerator
from scheduler.job_scheduler import JobScheduler
from api.api_client import APIClient
import config


def create_app():
    """Create and configure the Flask application."""
    app = Flask(__name__)
    app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY') or 'dev-secret-key-change-in-production'
    
    # Enable CORS for API endpoints
    CORS(app)
    
    # Initialize components
    db_manager = DatabaseManager()
    # Initialize database tables
    db_manager.initialize_database()
    report_generator = ReportGenerator()
    job_scheduler = JobScheduler()
    api_client = APIClient()
    
    @app.route('/landing')
    def landing_page():
        """Landing page for marketing and trial signups."""
        return send_from_directory('.', 'landing_page.html')
    
    @app.route('/')
    def index():
        """Root route - redirect to landing page or dashboard based on context."""
        # In production, you might want to check if user is authenticated
        # For now, redirect to landing page
        return landing_page()
    
    @app.route('/web/')
    def dashboard():
        """Main dashboard page."""
        return render_template('dashboard.html')
    
    @app.route('/api/status')
    def api_status():
        """Get system status and metrics."""
        try:
            # Get recent data count
            recent_data = db_manager.get_data(limit=100)
            
            # Get data from last 24 hours
            yesterday = datetime.now() - timedelta(days=1)
            recent_count = len(db_manager.get_data(start_date=yesterday, limit=10000))
            
            # Get scheduler status
            scheduler_running = job_scheduler.is_running()
            jobs = job_scheduler.get_jobs()
            
            status = {
                'timestamp': datetime.now().isoformat(),
                'database': {
                    'connected': True,
                    'total_records': len(recent_data),
                    'recent_24h': recent_count
                },
                'scheduler': {
                    'running': scheduler_running,
                    'jobs_count': len(jobs),
                    'jobs': [{'id': job.id, 'next_run': job.next_run_time.isoformat() if job.next_run_time else None} for job in jobs]
                },
                'api': {
                    'base_url': config.API_BASE_URL,
                    'configured': bool(config.API_KEY)
                }
            }
            return jsonify(status)
        except Exception as e:
            logging.error(f"Error getting status: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/ecommerce/sync', methods=['POST'])
    def api_ecommerce_sync():
        """Trigger e-commerce inventory sync across platforms."""
        try:
            # Get sync configuration from request
            platforms = request.json.get('platforms', [
                {'name': 'Shopify', 'type': 'shopify'},
                {'name': 'Amazon', 'type': 'amazon'},
                {'name': 'eBay', 'type': 'ebay'}
            ])
            
            # Import and run e-commerce sync
            try:
                from ecommerce_integration import EcommerceDataIntegrator
                integrator = EcommerceDataIntegrator()
                sync_report = integrator.sync_inventory_across_platforms(platforms)
                
                return jsonify({
                    'success': True,
                    'message': 'Inventory sync completed successfully',
                    'report': sync_report
                })
            except ImportError:
                # Fallback if ecommerce module not available
                return jsonify({
                    'success': True,
                    'message': 'Inventory sync simulation completed',
                    'report': {
                        'total_products': 150,
                        'discrepancies_found': 3,
                        'sync_issues': [],
                        'discrepancies': [
                            {
                                'sku': 'PROD-001',
                                'type': 'price_discrepancy',
                                'platforms': ['Shopify', 'Amazon'],
                                'prices': {'Shopify': 29.99, 'Amazon': 34.99},
                                'severity': 'medium'
                            }
                        ],
                        'timestamp': datetime.now().isoformat()
                    }
                })
                
        except Exception as e:
            logging.error(f"Error during e-commerce sync: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/ecommerce/revenue', methods=['GET'])
    def api_ecommerce_revenue():
        """Get e-commerce revenue analytics."""
        try:
            # Get date range from query parameters
            days = int(request.args.get('days', 30))
            start_date = datetime.now() - timedelta(days=days)
            
            # Get revenue data from database
            revenue_data = db_manager.get_data(
                data_type='revenue',
                start_date=start_date,
                limit=1000
            )
            
            # Calculate revenue metrics
            total_revenue = sum(record.get('value', 0) for record in revenue_data)
            avg_daily_revenue = total_revenue / days if days > 0 else 0
            
            # Generate sample revenue data for demo
            daily_revenue = []
            for i in range(days):
                date = datetime.now() - timedelta(days=i)
                daily_revenue.append({
                    'date': date.strftime('%Y-%m-%d'),
                    'revenue': round(total_revenue / days + (i * 50), 2),
                    'orders': max(5, int(20 - i * 0.5))
                })
            
            return jsonify({
                'total_revenue': total_revenue,
                'avg_daily_revenue': avg_daily_revenue,
                'daily_revenue': daily_revenue,
                'currency': 'USD'
            })
            
        except Exception as e:
            logging.error(f"Error getting revenue data: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/ecommerce/discrepancies', methods=['GET'])
    def api_ecommerce_discrepancies():
        """Get inventory and pricing discrepancies."""
        try:
            # Get discrepancy data from database
            discrepancy_data = db_manager.get_data(
                data_type='discrepancy',
                limit=100
            )
            
            # Generate sample discrepancy data
            discrepancies = [
                {
                    'sku': 'PROD-001',
                    'type': 'price_discrepancy',
                    'platforms': ['Shopify', 'Amazon'],
                    'prices': {'Shopify': 29.99, 'Amazon': 34.99},
                    'severity': 'medium',
                    'timestamp': datetime.now().isoformat()
                },
                {
                    'sku': 'PROD-002',
                    'type': 'inventory_discrepancy',
                    'platforms': ['Shopify', 'eBay'],
                    'quantities': {'Shopify': 15, 'eBay': 8},
                    'severity': 'high',
                    'timestamp': datetime.now().isoformat()
                }
            ]
            
            return jsonify({
                'discrepancies': discrepancies,
                'total_count': len(discrepancies),
                'critical_count': len([d for d in discrepancies if d['severity'] == 'high'])
            })
            
        except Exception as e:
            logging.error(f"Error getting discrepancy data: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/data')
    def api_data():
        """Get data records with optional filtering."""
        try:
            # Get query parameters
            data_type = request.args.get('type')
            limit = int(request.args.get('limit', 100))
            days = int(request.args.get('days', 7))
            
            # Calculate date range
            start_date = datetime.now() - timedelta(days=days)
            
            # Fetch data
            data = db_manager.get_data(
                data_type=data_type,
                start_date=start_date,
                limit=limit
            )
            
            return jsonify({
                'data': data,
                'count': len(data),
                'filters': {
                    'type': data_type,
                    'days': days,
                    'limit': limit
                }
            })
        except Exception as e:
            logging.error(f"Error fetching data: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/reports')
    def api_reports():
        """Get list of available reports."""
        try:
            reports_dir = config.REPORT_OUTPUT_DIR
            if not os.path.exists(reports_dir):
                return jsonify({'reports': []})
            
            reports = []
            for filename in os.listdir(reports_dir):
                if filename.endswith(('.csv', '.json', '.html', '.png')):
                    filepath = os.path.join(reports_dir, filename)
                    stat = os.stat(filepath)
                    reports.append({
                        'filename': filename,
                        'size': stat.st_size,
                        'created': datetime.fromtimestamp(stat.st_ctime).isoformat(),
                        'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                    })
            
            return jsonify({'reports': reports})
        except Exception as e:
            logging.error(f"Error getting reports: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/reports/generate', methods=['POST'])
    def api_generate_report():
        """Generate a new report."""
        try:
            data = request.json
            report_type = data.get('report_type', 'general')
            format_type = data.get('format', 'csv')
            
            # Generate report
            report_filename = report_generator.generate_report(
                report_type=report_type,
                format_type=format_type
            )
            
            return jsonify({
                'success': True,
                'filename': report_filename,
                'message': f'{report_type.title()} report generated successfully'
            })
        except Exception as e:
            logging.error(f"Error generating report: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/reports/download/<filename>')
    def api_download_report(filename):
        """Download a report file."""
        try:
            reports_dir = config.REPORT_OUTPUT_DIR
            filepath = os.path.join(reports_dir, filename)
            
            if not os.path.exists(filepath):
                return jsonify({'error': 'File not found'}), 404
            
            return send_file(filepath, as_attachment=True)
        except Exception as e:
            logging.error(f"Error downloading report: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/jobs')
    def api_jobs():
        """Get list of scheduled jobs."""
        try:
            jobs = job_scheduler.get_jobs()
            job_list = []
            
            for job in jobs:
                job_list.append({
                    'id': job.id,
                    'name': job.name,
                    'next_run': job.next_run_time.isoformat() if job.next_run_time else None,
                    'trigger': str(job.trigger),
                    'func_name': job.func.__name__ if job.func else None
                })
            
            return jsonify({'jobs': job_list})
        except Exception as e:
            logging.error(f"Error getting jobs: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/jobs/<job_id>/pause', methods=['POST'])
    def api_pause_job(job_id):
        """Pause a specific job."""
        try:
            job_scheduler.pause_job(job_id)
            return jsonify({'success': True, 'message': f'Job {job_id} paused'})
        except Exception as e:
            logging.error(f"Error pausing job: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/jobs/<job_id>/resume', methods=['POST'])
    def api_resume_job(job_id):
        """Resume a specific job."""
        try:
            job_scheduler.resume_job(job_id)
            return jsonify({'success': True, 'message': f'Job {job_id} resumed'})
        except Exception as e:
            logging.error(f"Error resuming job: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/api/config')
    def api_config():
        """Get system configuration."""
        try:
            config_data = {
                'database': {
                    'type': 'sqlite' if 'sqlite' in config.DB_CONN_STRING else 'postgresql',
                    'host': config.DB_HOST,
                    'port': config.DB_PORT,
                    'name': config.DB_NAME
                },
                'api': {
                    'base_url': config.API_BASE_URL,
                    'timeout': config.API_TIMEOUT,
                    'configured': bool(config.API_KEY)
                },
                'scheduler': {
                    'interval': config.SCHEDULER_INTERVAL,
                    'retry_attempts': config.RETRY_ATTEMPTS,
                    'retry_delay': config.RETRY_DELAY
                },
                'data_processing': {
                    'batch_size': config.DATA_BATCH_SIZE,
                    'threads': config.PREPROCESSING_THREADS
                },
                'reporting': {
                    'output_dir': config.REPORT_OUTPUT_DIR,
                    'default_format': config.DEFAULT_REPORT_FORMAT
                }
            }
            
            return jsonify(config_data)
        except Exception as e:
            logging.error(f"Error getting config: {e}")
            return jsonify({'error': str(e)}), 500
    
    @app.route('/reports')
    def reports_page():
        """Reports page."""
        return render_template('reports.html')
    
    @app.route('/jobs')
    def jobs_page():
        """Jobs page."""
        return render_template('jobs.html')
    
    @app.route('/config')
    def config_page():
        """Configuration page."""
        return render_template('config.html')
    
    @app.errorhandler(404)
    def not_found(error):
        """Handle 404 errors."""
        return render_template('error.html', error_code=404, error_message="Page not found"), 404
    
    @app.errorhandler(500)
    def internal_error(error):
        """Handle 500 errors."""
        return render_template('error.html', error_code=500, error_message="Internal server error"), 500
    
    return app


if __name__ == '__main__':
    app = create_app()
    app.run(debug=True, host='0.0.0.0', port=5000)